<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' blob: data:;">
<title>Twitch Chat Overlay (WebSocket IRC)</title>
<style>
  /* Transparence totale pour OBS */
  html, body {
    background: transparent !important;
    margin: 0;
    padding: 12px;
    overflow: hidden;
  }

  /* Conteneur du chat */
  #chat {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  /* Style d’un message */
  .message {
    opacity: 0;
    color: #fff;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 20px;
    line-height: 1.3;
    text-shadow: 0 0 5px #fff, 0 0 10px #fff;
    animation: appear 0.35s ease-out forwards, glitch 0.28s 0.35s ease-out;
    will-change: opacity, transform, text-shadow;
  }

  .nick {
    color: #fff;
    font-weight: 700;
    margin-right: 6px;
    text-shadow: 0 0 6px #fff;
  }

  .text {
    color: #fff;
  }

  @keyframes appear {
    from { opacity: 0; transform: translateX(-16px); }
    to   { opacity: 1; transform: translateX(0); }
  }

  @keyframes glitch {
    0%   { text-shadow: 2px 0 #ff004d, -2px 0 #00e5ff, 0 0 8px #fff; }
    50%  { text-shadow: -2px 0 #ff004d, 2px 0 #00e5ff, 0 0 4px #fff; }
    100% { text-shadow: 0 0 0 #0000, 0 0 0 #0000, 0 0 6px #fff; }
  }
</style>
</head>
<body>
  <div id="chat"></div>

  <script>
    // ====== CONFIG ======
    const CHANNEL = "alternate_reality_";     // <- ton channel (minuscule)
    const MESSAGE_LIFETIME = 12000;           // durée d’affichage de chaque message (ms)
    const MAX_MESSAGES = 20;                  // limite de messages affichés simultanément
    // ====================

    const wsUrl = "wss://irc-ws.chat.twitch.tv:443";
    let socket;
    let reconnectTimer = null;

    // Petit helper : pseudo anonyme "justinfanXXXX"
    function randomJustinFan() {
      const n = Math.floor(Math.random() * 1e6);
      return "justinfan" + n;
    }

    function connect() {
      socket = new WebSocket(wsUrl);

      socket.addEventListener("open", () => {
        // Demande des "tags" pour récupérer display-name, badges, etc.
        sendLine("CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership");

        // Connexion anonyme :
        // La plupart des implémentations acceptent PASS SCHMOOPIIE avec justinfan.
        // Si jamais ta version refuse, essaie PASS oauth:anonymous.
        sendLine("PASS oauth:p7ctg8j9od59eg6taxxnhting51a3m");
        sendLine("NICK " + randomJustinFan());
        sendLine("JOIN #" + CHANNEL);
      });

      socket.addEventListener("message", (event) => {
        // Un frame peut contenir plusieurs lignes IRC séparées par \r\n
        const lines = event.data.split("\r\n").filter(Boolean);
        for (const line of lines) {
          handleLine(line);
        }
      });

      socket.addEventListener("close", () => scheduleReconnect());
      socket.addEventListener("error", () => scheduleReconnect());
    }

    function scheduleReconnect() {
      if (reconnectTimer) return;
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connect();
      }, 2000); // essaie de se reconnecter au bout de 2s
    }

    function sendLine(s) {
      try { socket && socket.send(s); } catch(e) {}
    }

    function handleLine(line) {
      // Réponse keep-alive
      if (line.startsWith("PING")) {
        sendLine("PONG :tmi.twitch.tv");
        return;
      }

      // Exemple de PRIVMSG avec tags :
      // @badge-info=;badges=;color=;display-name=User;... :user!user@user.tmi.twitch.tv PRIVMSG #channel :hello
      // On va parser minimalement les tags et le message
      const parsed = parseIRC(line);
      if (!parsed) return;

      if (parsed.command === "PRIVMSG" && parsed.params && parsed.params.channel === CHANNEL) {
        const displayName = parsed.tags["display-name"] || parsed.prefix?.nick || "???";
        const text = parsed.params.message || "";

        addMessage(displayName, text);
      }
    }

    function parseIRC(line) {
      // Parsing minimal de la RFC IRC + tags Twitch
      let rest = line;
      const result = { tags: {}, prefix: null, command: null, params: null };

      // Tags (@tag1=val;tag2=val)
      if (rest.startsWith("@")) {
        const end = rest.indexOf(" ");
        const rawTags = rest.slice(1, end).split(";");
        for (const t of rawTags) {
          const [k, v=""] = t.split("=");
          result.tags[k] = v.replace(/\\s/g, " ").replace(/\\:/g, ";");
        }
        rest = rest.slice(end + 1);
      }

      // Prefix (:nick!user@host)
      if (rest.startsWith(":")) {
        const end = rest.indexOf(" ");
        const prefix = rest.slice(1, end);
        result.prefix = parsePrefix(prefix);
        rest = rest.slice(end + 1);
      }

      // Command + params
      const space = rest.indexOf(" ");
      let command = rest;
      let paramsPart = "";
      if (space !== -1) {
        command = rest.slice(0, space);
        paramsPart = rest.slice(space + 1);
      }
      result.command = command;

      // PRIVMSG params → "#channel :message"
      if (command === "PRIVMSG") {
        const hash = paramsPart.indexOf(" #");
        // parfois c’est déjà sans espace
        const channelMatch = paramsPart.match(/#([^\s]+)/);
        const msgIndex = paramsPart.indexOf(" :");
        const channel = channelMatch ? channelMatch[1].toLowerCase() : CHANNEL;
        const message = msgIndex !== -1 ? paramsPart.slice(msgIndex + 2) : "";
        result.params = { channel, message };
      }

      return result;
    }

    function parsePrefix(prefix) {
      // "nick!user@host"
      const ex1 = prefix.split("!");
      const nick = ex1[0] || null;
      return { nick };
    }

    // === Affichage DOM ===
    const chat = document.getElementById("chat");

    function addMessage(nick, text) {
      // Limiter le nombre de messages affichés
      while (chat.children.length >= MAX_MESSAGES) {
        chat.removeChild(chat.firstChild);
      }

      const el = document.createElement("div");
      el.className = "message";

      const nickEl = document.createElement("span");
      nickEl.className = "nick";
      nickEl.textContent = nick + ":";

      const textEl = document.createElement("span");
      textEl.className = "text";
      textEl.textContent = " " + text;

      el.appendChild(nickEl);
      el.appendChild(textEl);
      chat.appendChild(el);

      // Auto-suppression après MESSAGE_LIFETIME
      setTimeout(() => {
        if (el && el.parentNode) el.parentNode.removeChild(el);
      }, MESSAGE_LIFETIME);
    }

    // Démarrage
    connect();
  </script>
</body>
</html>
